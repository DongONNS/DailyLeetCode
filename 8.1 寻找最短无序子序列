public class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int l = nums.length, r = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] < nums[i]) {
                    r = Math.max(r, j);
                    l = Math.min(l, i);
                }
            }
        }
        return r - l < 0 ? 0 : r - l + 1;
    }
}



/*
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        //记录数组的长度；
        int len = nums.length;
        int res = len;
        //暴力三层for循环；
        //第一层用于控制循环轮数；
        for(int i=0;i<len;i++){
            for(int j=i;j<=len;j++){
                int min  = Integer.MAX_VALUE;
                int max  = Integer.MIN_VALUE;
                int prev = Integer.MIN_VALUE;
                //这样就隔离开了我们需要尝试的[i,j]之间的数；
                for(int k=i;k<j;k++){
                    //得到i-j之间的最大值和最小值
                    min = Math.min(min,nums[k]);
                    max = Math.max(max,nums[k]);
                }
                if((i>0&&nums[i-1]>min)||(j<len&&nums[j]<max)){
                    continue;
                }
                //判断[0-i]之间的数字是否符合按升序排列并且都小于中间数组的最小值
                int k=0;
                while(k<i&&prev<=nums[k]){
                    prev=nums[k];
                    k++;
                }
                if(k!=i){
                    continue;
                }
                //判断[j-len]之间的数字是否符合按升序排列
                k=j;
                while(k<len&&prev<=nums[k]){
                    prev=nums[k];
                    k++;
                }
                //如果这个程序可以一路顺利到最后，那么就记录这个情况下的序列长度；
                if(k==len){
                   res = Math.min(res,j-i); 
                }
            }
        }
        return res;
    }
}
*/
